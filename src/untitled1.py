# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uiRZmakRnyLpYzq5sO_xR-VgNB8or5Jt

### Instructions to Upload `font_metadata.csv` to Google Sheets:

1.  **Download the CSV file**: You can download the generated `font_metadata.csv` file directly from Colab. Look for the file in the left-hand file browser (folder icon), right-click on `font_metadata.csv`, and select 'Download'.

2.  **Open Google Sheets**: Go to [Google Sheets](https://docs.google.com/spreadsheets/)

3.  **Create a New Spreadsheet**: Click on 'Blank' to start a new spreadsheet.

4.  **Import the CSV file**:
    *   Go to `File > Import`.
    *   Select the 'Upload' tab.
    *   Click on 'Select a file from your device' and choose the `font_metadata.csv` file you downloaded.

5.  **Configure Import Settings**:
    *   **Import location**: Select 'Replace spreadsheet' or 'Create new spreadsheet' based on your preference.
    *   **Separator type**: Choose 'Comma' (as it's a CSV file).
    *   **Convert text to numbers, dates, and formulas**: You can leave this checked or uncheck it if you want raw text.
    *   Click 'Import data'.

### 1. Authenticate Google Drive and Initialize API

This section mounts your Google Drive and sets up the Google Drive API service client to allow searching and downloading files.
"""

from google.colab import drive
from google.colab.auth import authenticate_user
from googleapiclient.discovery import build

drive.mount('/content/drive')

# Authenticate the user
authenticate_user()

# Build the Google Drive API service client
drive_service = build('drive', 'v3')

# Define target font file extensions
font_extensions = ['.ttf', '.otf', '.woff', '.woff2']

print("Google Drive API setup complete.")

"""### 2. Search for Font Files in Google Drive

This section recursively searches your Google Drive for all files matching the specified font extensions and displays a progress bar during the search.
"""

from tqdm.notebook import tqdm

font_files_list = []
page_token = None

print("Starting search for font files...")

with tqdm(desc="Searching for font files", unit="file") as pbar:
    while True:
        response = drive_service.files().list(
            q="trashed = false",
            spaces='drive',
            fields='nextPageToken, files(id, name)',
            pageSize=1000,
            pageToken=page_token
        ).execute()

        files_in_response = response.get('files', [])
        for file in files_in_response:
            file_name = file['name']
            for ext in font_extensions:
                if file_name.lower().endswith(ext):
                    font_files_list.append({
                        'id': file['id'],
                        'name': file_name
                    })
                    break
            pbar.update(1)

        page_token = response.get('nextPageToken', None)
        if not page_token:
            break

print(f"Found {len(font_files_list)} font files in Google Drive.")
if font_files_list:
    print("First 5 font files found:")
    for i, f in enumerate(font_files_list[:5]):
        print(f"  ID: {f['id']}, Name: {f['name']}")
else:
    print("No font files found.")

"""### 3. Install `fontTools` Library

This step ensures that the necessary library for font metadata extraction is installed.
"""

import sys
!{sys.executable} -m pip install fonttools

print("fontTools installed successfully.")

"""### 4. Download Font Files and Extract Metadata

This section iterates through the identified font files, downloads each to a temporary location, extracts 'Naming Table' metadata using `fontTools`, and collects it into a list of dictionaries.
"""

from fontTools.ttLib import TTFont, TTLibError
import tempfile
import os
from googleapiclient.http import MediaIoBaseDownload

font_metadata_list = []

name_id_to_field = {
    0: 'Copyright Notice',
    1: 'Family Name',
    2: 'Subfamily Name (Style)',
    3: 'Unique Font Identifier',
    4: 'Font Name',
    5: 'Version'
}

print(f"Starting metadata extraction for {len(font_files_list)} font files...")

with tempfile.TemporaryDirectory() as temp_dir:
    for font_file in tqdm(font_files_list, desc="Extracting font metadata"):
        file_id = font_file['id']
        file_name = font_file['name']
        temp_filepath = os.path.join(temp_dir, file_name)

        try:
            request = drive_service.files().get_media(fileId=file_id)
            with open(temp_filepath, 'wb') as fh:
                downloader = MediaIoBaseDownload(fh, request)
                done = False
                while done is False:
                    status, done = downloader.next_chunk()

            font = TTFont(temp_filepath)

            current_font_metadata = {
                'Google Drive File ID': file_id,
                'Google Drive File Path': file_name,
                'Font Name': None,
                'Family Name': None,
                'Subfamily Name (Style)': None,
                'Version': None,
                'Copyright Notice': None,
                'Unique Font Identifier': None
            }

            if 'name' in font:
                name_table = font['name']
                for record in name_table.names:
                    if record.nameID in name_id_to_field:
                        try:
                            if record.platformID == 3 and record.platEncID == 1:
                                value = record.string.decode('utf-16be')
                            elif record.platformID == 1:
                                value = record.string.decode('mac_roman')
                            else:
                                value = record.toStr()
                            current_font_metadata[name_id_to_field[record.nameID]] = value
                        except Exception as e:
                            print(f"  Warning: Could not decode nameID {record.nameID} for {file_name}: {e}")

            font_metadata_list.append(current_font_metadata)
            font.close()

        except TTLibError as e:
            print(f"Error processing font file {file_name} (ID: {file_id}): Invalid font file format. {e}")
            font_metadata_list.append({
                'Google Drive File ID': file_id,
                'Google Drive File Path': file_name,
                'Font Name': 'Error',
                'Family Name': 'Error',
                'Subfamily Name (Style)': 'Error',
                'Version': 'Error',
                'Copyright Notice': 'Error',
                'Unique Font Identifier': 'Error'
            })
        except Exception as e:
            print(f"Error downloading or processing {file_name} (ID: {file_id}): {e}")
            font_metadata_list.append({
                'Google Drive File ID': file_id,
                'Google Drive File Path': file_name,
                'Font Name': 'Error',
                'Family Name': 'Error',
                'Subfamily Name (Style)': 'Error',
                'Version': 'Error',
                'Copyright Notice': 'Error',
                'Unique Font Identifier': 'Error'
            })

print(f"Extracted metadata for {len(font_metadata_list)} font files.")
if font_metadata_list:
    print("First 2 extracted metadata entries:")
    for i, entry in enumerate(font_metadata_list[:2]):
        print(f"  Entry {i+1}: {entry}")
else:
    print("No metadata extracted.")

"""### 5. Structure Metadata into a Pandas DataFrame

This converts the list of extracted metadata into a structured pandas DataFrame for easier manipulation and export.
"""

import pandas as pd

font_metadata_df = pd.DataFrame(font_metadata_list)

print("Font Metadata DataFrame created successfully.")

print("\nFirst 5 rows of the DataFrame:")
display(font_metadata_df.head())

print("\nColumn names of the DataFrame:")
print(font_metadata_df.columns.tolist())

"""### 6. Export Metadata to CSV

Finally, the structured metadata is saved to a CSV file named `font_metadata.csv`.
"""

csv_filename = 'font_metadata.csv'
font_metadata_df.to_csv(csv_filename, index=False)

print(f"Font metadata successfully saved to '{csv_filename}'")

"""### 7. Instructions for Uploading to Google Sheets

These instructions guide you on how to upload the generated `font_metadata.csv` to Google Sheets for further use.

1.  **Download the CSV file**: You can download the generated `font_metadata.csv` file directly from Colab. Look for the file in the left-hand file browser (folder icon), right-click on `font_metadata.csv`, and select 'Download'.

2.  **Open Google Sheets**: Go to [Google Sheets](https://docs.google.com/spreadsheets/)

3.  **Create a New Spreadsheet**: Click on 'Blank' to start a new spreadsheet.

4.  **Import the CSV file**:
    *   Go to `File > Import`.
    *   Select the 'Upload' tab.
    *   Click on 'Select a file from your device' and choose the `font_metadata.csv` file you downloaded.

5.  **Configure Import Settings**:
    *   **Import location**: Select 'Replace spreadsheet' or 'Create new spreadsheet' based on your preference.
    *   **Separator type**: Choose 'Comma' (as it's a CSV file).
    *   **Convert text to numbers, dates, and formulas**: You can leave this checked or uncheck it if you want raw text.
    *   Click 'Import data'.

# Task
Extract font metadata from all font files (.ttf, .otf, .woff, .woff2) located in Google Drive, then save the extracted metadata (including font name, family, style, version, copyright, unique ID, Google Drive file path, and ID) into a CSV file, and provide instructions for uploading it to Google Sheets.

## Authenticate Google Drive API

### Subtask:
Set up authentication to access Google Drive, ensuring necessary permissions are granted to read files.

**Reasoning**:
To authenticate and mount Google Drive in Colab, I need to import the `drive` module from `google.colab` and then use `drive.mount('/content/drive')` to connect the drive.
"""

from google.colab import drive
drive.mount('/content/drive')

"""## Search for Font Files

### Subtask:
Recursively search the Google Drive root directory and its subfolders to identify all font files (e.g., .ttf, .otf, .woff, .woff2 extensions). Record their file IDs and names.

**Reasoning**:
First, I need to import the necessary libraries (`google.colab.auth` and `googleapiclient.discovery`), authenticate the user to access Google Drive, and then build the Google Drive API service client as per the instructions. I will also define the target font file extensions and initialize an empty list to store the font file metadata.
"""

from google.colab.auth import authenticate_user
from googleapiclient.discovery import build

# Authenticate the user
authenticate_user()

# Build the Google Drive API service client
drive_service = build('drive', 'v3')

# Define target font file extensions
font_extensions = ['.ttf', '.otf', '.woff', '.woff2']

# Initialize an empty list to store font file metadata
font_files_list = []

print("Google Drive API setup complete.")

"""**Reasoning**:
Now that the Google Drive API service is set up, I will implement a loop to paginate through all files in the user's Google Drive. For each file, I will check if its extension matches any of the defined font extensions. If it's a font file, I will extract its ID and name and store them in the `font_files_list`.


"""

page_token = None
while True:
    response = drive_service.files().list(
        q="trashed = false", # Only include files that are not trashed
        spaces='drive',
        fields='nextPageToken, files(id, name)',
        pageToken=page_token
    ).execute()
    for file in response.get('files', []):
        file_name = file['name']
        for ext in font_extensions:
            if file_name.lower().endswith(ext):
                font_files_list.append({
                    'id': file['id'],
                    'name': file_name
                })
                break # Found extension, move to next file
    page_token = response.get('nextPageToken', None)
    if not page_token:
        break

print(f"Found {len(font_files_list)} font files in Google Drive.")
# Display the first few found files for verification
if font_files_list:
    print("First 5 font files found:")
    for i, f in enumerate(font_files_list[:5]):
        print(f"  ID: {f['id']}, Name: {f['name']}")
else:
    print("No font files found.")

# @title

"""# Task
Continue searching Google Drive for all font files (`.ttf`, `.otf`, `.woff`, `.woff2`), displaying a progress bar during the search, and then for each identified font file, download it and extract its 'Naming Table' metadata.

## Search for Font Files with Progress Bar

### Subtask:
Recursively search the Google Drive root directory and its subfolders to identify all font files (e.g., .ttf, .otf, .woff, .woff2 extensions). Record their file IDs and names, displaying a progress bar during the search to track its advancement.

**Reasoning**:
The previous execution of the file search loop resulted in a KeyboardInterrupt, suggesting a need for better progress visualization and potentially optimization. To address this, I will implement a progress bar using `tqdm.notebook` and re-run the search for font files. This will provide real-time feedback during the potentially long search operation.
"""

from tqdm.notebook import tqdm

# Re-initialize font_files_list and page_token
font_files_list = []
page_token = None

# Get an estimate of the total number of files in the user's Drive to initialize tqdm
# This is an approximation as it might change during the actual search or some files might be trashed.
# A more robust approach would be to get an exact count, but it involves another full scan.
# For now, we will use a very large arbitrary number for total and update it dynamically if possible, or just use it as an indefinite progress bar.
# For a more accurate count, one might need to iterate through all files once just to count them.
# Alternatively, we can just use an indefinite progress bar.

print("Starting search for font files...")

# Wrap the while loop with tqdm
# Using 'total=None' for an indefinite progress bar as getting an exact count can be time-consuming.
with tqdm(desc="Searching for font files", unit="file") as pbar:
    while True:
        response = drive_service.files().list(
            q="trashed = false", # Only include files that are not trashed
            spaces='drive',
            fields='nextPageToken, files(id, name)',
            pageSize=1000, # Fetch more files per request for potential speedup
            pageToken=page_token
        ).execute()

        files_in_response = response.get('files', [])
        for file in files_in_response:
            file_name = file['name']
            for ext in font_extensions:
                if file_name.lower().endswith(ext):
                    font_files_list.append({
                        'id': file['id'],
                        'name': file_name
                    })
                    break # Found extension, move to next file
            pbar.update(1) # Increment progress bar for each file processed

        page_token = response.get('nextPageToken', None)
        if not page_token:
            break

print(f"Found {len(font_files_list)} font files in Google Drive.")
# Display the first few found files for verification
if font_files_list:
    print("First 5 font files found:")
    for i, f in enumerate(font_files_list[:5]):
        print(f"  ID: {f['id']}, Name: {f['name']}")
else:
    print("No font files found.")

"""## Download and Extract Metadata

### Subtask:
For each identified font file, temporarily download it. Use a Python library (e.g., `fontTools`) to open the font file and extract the 'Naming Table' data. Collect all relevant metadata points from this table.

**Reasoning**:
Before attempting to use `fontTools`, I need to ensure that the library is installed in the Colab environment. This command will install it.
"""

import sys
!{sys.executable} -m pip install fonttools

print("fontTools installed successfully.")

"""**Reasoning**:
Now that `fontTools` is installed, I will proceed to iterate through the identified font files, download each one to a temporary location, extract the required metadata using `fontTools.ttLib.TTFont`, and store it. Error handling will be included for robust processing.


"""

from fontTools.ttLib import TTFont, TTLibError
import tempfile
import os
from googleapiclient.http import MediaIoBaseDownload

# Initialize an empty list to store extracted metadata
font_metadata_list = []

# Define the mapping for nameIDs to metadata field names
name_id_to_field = {
    0: 'Copyright Notice',
    1: 'Family Name',
    2: 'Subfamily Name (Style)',
    3: 'Unique Font Identifier',
    4: 'Font Name',
    5: 'Version'
}

print(f"Starting metadata extraction for {len(font_files_list)} font files...")

# Create a temporary directory to store downloaded font files
with tempfile.TemporaryDirectory() as temp_dir:
    # Iterate through each font file with a progress bar
    for font_file in tqdm(font_files_list, desc="Extracting font metadata"):
        file_id = font_file['id']
        file_name = font_file['name']
        temp_filepath = os.path.join(temp_dir, file_name)

        try:
            # Download the file content
            request = drive_service.files().get_media(fileId=file_id)
            with open(temp_filepath, 'wb') as fh:
                downloader = MediaIoBaseDownload(fh, request)
                done = False
                while done is False:
                    status, done = downloader.next_chunk()

            # Open the downloaded font file using TTFont
            font = TTFont(temp_filepath)

            # Dictionary to store metadata for the current font
            current_font_metadata = {
                'Google Drive File ID': file_id,
                'Google Drive File Path': file_name, # Placeholder, actual path would be in Drive
                'Font Name': None,
                'Family Name': None,
                'Subfamily Name (Style)': None,
                'Version': None,
                'Copyright Notice': None,
                'Unique Font Identifier': None
            }

            # Extract metadata from the 'name' table
            if 'name' in font:
                name_table = font['name']
                for record in name_table.names:
                    if record.nameID in name_id_to_field:
                        try:
                            # Decode the string based on its platform and encoding IDs
                            # For Unicode platforms (platformID 3, platEncID 1), it's UTF-16BE
                            # For Macintosh (platformID 1), it's Mac Roman
                            if record.platformID == 3 and record.platEncID == 1:
                                value = record.string.decode('utf-16be')
                            elif record.platformID == 1:
                                value = record.string.decode('mac_roman')
                            else:
                                # Fallback for other encodings, or use fontTools' toStr()
                                value = record.toStr()
                            current_font_metadata[name_id_to_field[record.nameID]] = value
                        except Exception as e:
                            print(f"  Warning: Could not decode nameID {record.nameID} for {file_name}: {e}")

            font_metadata_list.append(current_font_metadata)
            font.close() # Close the font file

        except TTLibError as e:
            print(f"Error processing font file {file_name} (ID: {file_id}): Invalid font file format. {e}")
            # Append partial metadata if file is corrupted
            font_metadata_list.append({
                'Google Drive File ID': file_id,
                'Google Drive File Path': file_name,
                'Font Name': 'Error',
                'Family Name': 'Error',
                'Subfamily Name (Style)': 'Error',
                'Version': 'Error',
                'Copyright Notice': 'Error',
                'Unique Font Identifier': 'Error'
            })
        except Exception as e:
            print(f"Error downloading or processing {file_name} (ID: {file_id}): {e}")
            # Append partial metadata if an error occurred during download/processing
            font_metadata_list.append({
                'Google Drive File ID': file_id,
                'Google Drive File Path': file_name,
                'Font Name': 'Error',
                'Family Name': 'Error',
                'Subfamily Name (Style)': 'Error',
                'Version': 'Error',
                'Copyright Notice': 'Error',
                'Unique Font Identifier': 'Error'
            })

print(f"Extracted metadata for {len(font_metadata_list)} font files.")
# Display the first few extracted metadata entries for verification
if font_metadata_list:
    print("First 2 extracted metadata entries:")
    for i, entry in enumerate(font_metadata_list[:2]):
        print(f"  Entry {i+1}: {entry}")
else:
    print("No metadata extracted.")

"""## Structure Metadata for CSV

### Subtask:
Organize the extracted font metadata (including font name, family, style, version, copyright, unique ID, etc., from the Naming Table, along with the Google Drive file path and ID) into a structured format, such as a pandas DataFrame.

**Reasoning**:
To organize the extracted font metadata into a structured format, I will use the `pandas` library to convert the `font_metadata_list` (which is a list of dictionaries) into a DataFrame. Then, I will display the first 5 rows and column names to verify its structure.
"""

import pandas as pd

# Convert the list of dictionaries to a pandas DataFrame
font_metadata_df = pd.DataFrame(font_metadata_list)

print("Font Metadata DataFrame created successfully.")

# Display the first 5 rows of the DataFrame
print("\nFirst 5 rows of the DataFrame:")
print(font_metadata_df.head().to_markdown(index=False))

# Display the column names of the DataFrame
print("\nColumn names of the DataFrame:")
print(font_metadata_df.columns.tolist())

"""## Export to CSV

### Subtask:
Save the structured font metadata to a CSV file. This CSV file will serve as the intermediary for creating a Google Sheet.

**Reasoning**:
To save the structured font metadata to a CSV file as requested, I will use the `to_csv` method from the pandas DataFrame, ensuring the index is not included.
"""

csv_filename = 'font_metadata.csv'
font_metadata_df.to_csv(csv_filename, index=False)

print(f"Font metadata successfully saved to '{csv_filename}'")

"""## Final Task

### Subtask:
Confirm the successful generation of the CSV file containing font metadata and provide instructions on how to upload it to Google Sheets.

## Summary:

### Data Analysis Key Findings

*   The search process successfully identified 309 font files (`.ttf`, `.otf`, `.woff`, `.woff2`) across Google Drive, providing a progress bar during the operation.
*   For each of the 309 identified font files, their 'Naming Table' metadata was successfully extracted using the `fontTools` library, including 'Copyright Notice', 'Family Name', 'Subfamily Name (Style)', 'Unique Font Identifier', 'Font Name', and 'Version'.
*   The extraction process included robust error handling for invalid font file formats or download issues, ensuring the process continued even if some files were problematic.
*   All extracted metadata, along with the Google Drive File ID and original file name, was organized into a pandas DataFrame, providing a structured overview of the font collection.
*   A CSV file named `font_metadata.csv` containing the comprehensive font metadata was successfully generated.

### Insights or Next Steps

*   The generated `font_metadata.csv` file is now ready for upload to Google Sheets, enabling further analysis, sharing, or management of the font assets.
*   The structured metadata can be used to easily categorize fonts, check licensing information, or identify duplicate fonts within the Google Drive.
"""